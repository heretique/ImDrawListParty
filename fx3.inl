#define R return
#define C cos(u)
#define S sin(u)
#define W(i,m)for(I i=m;i--;)
using V = ImVec2; using F = float; using I = int; F L(V v) { R sqrt(v.x * v.x + v.y * v.y); }V M(V v, F m) { F d = L(v); if (d > m)R v / d * m; R v; }V N(V v) { R v / L(v); }V U(V v, F u) { R{ v.x * C - v.y * S,v.x * S + v.y * C }; }struct B { V p, v, a; I h; }; B z[50]; I t = 1; void FX(ImDrawList* d, V a, V b, V, ImVec4, F) { if (t) { W(i, 50) { B& o = z[i]; o.p = (b + a) / 2; F u = rand() % 99; o.v = { C,S }; o.h = i % 20 == 0; }t = 0; }W(i, 50) { auto& [p, v, f, h] = z[i]; V pa, pc, ps, ph; I c = 0, cc = 0, cs = 0, ch = 0; I hs = h ? 3 : 1; W(j, 50) { B& n = z[j]; F d = L(n.p - p); if (d > 0 && d < 20) { pa = pa + n.v; c++; }if (d > 0 && d < 20 * hs) { pc = pc + n.p; cc++; }if (d > 0 && d < 10) { ps = ps + (p - n.p) / d / d; cs++; }if (!h && n.h) { if (d > 0 && L(p + v - n.p) < 40) { ph = ph + (p - n.p) / d * 3; ch++; } } }if (c) { pa = N(pa / c) * 2 - v; }if (cc) { pc = N(pc / cc - p) * 2 - v; }if (cs) { ps = N(ps / cs) * 2 - v; }if (ch) { ph = N(ph / ch) - v; }f = M(ps * 2 + pa + pc, .03) + ph; v = v + f; v = M(v, 2); p = p + v; if (p.x < a.x - 2)p.x = b.x + 2; if (p.y < a.y - 2)p.y = b.y + 2; if (p.x > b.x + 2)p.x = a.x - 2; if (p.y > b.y + 2)p.y = a.y - 2; F u = atan2(v.x, -v.y); d->AddLine(p + U({ 0,-4 }, u), p + U({ 2,4 }, u), h ? 0xff0000ff : ~0); } }